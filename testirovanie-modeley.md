---
order: 11
title: Тестирование данных
---

Помимо разработки, одной из важнейших задач при работе с хранилищами данных является обеспечение качества и целостности данных. Для этого проводится тестирование, при котором выявляют аномалии и ошибки.

Понятно, что данные можно проверять точечно и вручную, но  автоматизированое тестирование позволяет сократить количество ошибок, укрепить доверие к данным и сократить трудозатраты разработчиков и аналитиков на эту операцию.

В данном разделе рассмотрим возможности dbt в части тестирования.

Тестирование в dbt – это выполнение определенных настроек в моделях, а также в других объектах проекта (источниках, CSV-файлах, «снэпшотах»), которые позволяют проверить целостность данных, а затем сообщить о результатах этих проверок.

В dbt тесты являются SQL-запросами, направленными на поиск «ошибочных» записей.

Например, если в настройках указано, что столбец (или поле) модели является уникальным, то тестовый запрос выбирает дубликаты. Если, согласно настройкам, столбец никогда не бывает нулевым, то тест ищет записи с нулевым значением этого столбца. Другими словами, если тестовый запрос не возвращает никаких записей, то тест считается успешно пройденным.

Данные в dbt  можно протестировать с помощью встроенной функциональности, а также с применением дополнительных библиотек («пакетов»).

В dbt существует два вида тестов:

-  тесты данных (data tests), которые помогают обеспечить качество данных;

-  модульные тесты (unit tests, возможно, удобнее их называть просто юнит-тесты), которые проверяют заложенную в модели логику.

Рассмотрим каждый из этих видов подробнее.

## Тесты данных (data tests)

Тесты данных (data tests) предназначены для проверки целостности данных при каждом запуске проекта.

При этом тесты на уровне данных бывают единичными (singular tests) и универсальными  (generic tests).

### Единичные тесты (singular tests)

Возможно, по-русски звучит как-то криво, но смысл названия в том, что этот тип тестов используется для какой-то одной конкретной цели. Он достаточно прост и содержит один единственный SELECT, который возвращает «ошибочные» записи. В этих тестах можно использовать  функциональность Jinja, как в dbt-моделях.

Единичные тесты располагаются в папке `tests` и выполняются автоматически при запуске команды `dbt test`.

Какие-то строгие правила наименования здесь не применяются. Главное, чтобы название теста отражало суть выполняемых в нем действий.

Итак, давайте напишем первый незамысловатый тест - проверим, что в данных отсутствуют отрицательные суммы по оплате.

Создайте в папке `tests` файл `check_payment_total_amount_is_positive.sql` и добавьте в него следующий код:

```sql
select

    payment_id,
    sum(amount)

from {{ ref('fct_payments') }}

group by 1

having sum(amount) < 0
```

<note type="lab" title="Примечение">

Не ставьте точку с запятой (;) в конце `select` единичного теста, иначе он свалится в ошибку.

</note>

![](./testirovanie-modeley.png "Рисунок 44. Добавление единичного теста (singular tests)"){width=1672px height=888px}

Так как с помощью тестов мы хотим упростить себе жизнь, то этих тестов может быть достаточно большое количество. Да, ранее было отмечено, что название теста должно отражать его суть, но дополнительные уточняющие комментарии не помешают, чтобы не запутаться. Для этого применяются настроечные YAML-файлы.

Создайте в папке `tests` файл `description.yml` и добавьте в него следующее содержимое:

<note type="lab" title="Примечание">

Название настроечного YAML-файла с комментариями может быть совершенно любым. Здесь самое главное, чтобы наименования тестов соответствовали наименованиям SQL-файлов с логикой тестов.

</note>

```yaml
version: 2
data_tests:
  - name: check_payment_total_amount_is_positive
    description: >
      Оплата за аренду автомобиля всегда имеет положительное значение (>= 0).
      Выборка записей, в которых общая сумма < 0, завершит тест с ошибкой.
```

Пройдемся по параметрам файла:

-  `version: 2`. Эта настройка была обязательной для версии dbt 1.4 и ниже. Сейчас она не обязательна, но все-таки разработчики рекомендуют оставить ее;

-  `data_tests` говорит о том, что в файле перечислены единичные тесты с их описанием:

   -  `name` - наименование теста (должно совпадать с наименованием SQL-файла),

   -  `description` - описание тестового сценария.

<note type="lab" title="Примечание">

Знак `>` в `description` применяется для разбиения текста на несколько строк. Если этот знак не указать, то текст описания будет отображаться в одну строку.

</note>

![](./testirovanie-modeley-2.png "Рисунок 45. Описание единичных тестов (singular tests)"){width=2006px height=934px}

Осталось запустить тест и убедиться, что данные в порядке, а заодно и ознакомиться с новой командой.

Запустите команду тестирования:

```sql
dbt test 
```

![](./testirovanie-modeley-3.png "Рисунок 46. Запуск единичных тестов (singular tests)"){width=1022px height=389px}

Подобные тесты конечно хороши, но неудобны тем, что написаны под конкретную модель и даже столбец. Но вполне может такое быть, что логика проверки одной модели аналогична и для другой. Разница будет только в названии этой самой модели и имени столбцов. В этом случае можно с уверенностью сказать, что такой тест уже не будет единичным. Для таких целей нужно использовать универсальные тесты данных (generic tests).

### Универсальные тесты (generic tests)

Универсальные тесты по своей сути повторяют функциональность dbt-макросов с параметрами, что позволяет применять одни и те же тесты к различным моделям. Но в отличие от макроса, код-блок которого начинается с ключевого слова `macro`, универсальные тесты начинаются ключевого слова `test`.

Прямо из коробки dbt предоставляет возможность использования четырех встроенных универсальных теста:

-  `unique` - проверка на отсутствие дубликатов. Как правило, эти тесты применяются к столбцам, которые являются  идентификаторами записей;

-  `not_null` - проверка на отсутствие нулевых значений, чтобы гарантировать наличие важной, с точки зрения аналитики, информации. Также может применяться в сочетании с `unique` к столбцам с идентификаторами;

-  `accepted_values` - проверка допустимых значений по бизнес-логике в определенных столбцах для обеспечения согласованности данных и контроля ввода недопустимых вариантов;

-  `relationships` - проверка связи внешних ключей между двумя таблицами.

Добавьте перечисленные универсальные тесты для таблиц фактов и измерений.

Сначала создайте в папке `models/marts/core/` файл `_dimensions_tests.yml` и добавьте в него следующий код:

```yaml
version: 2

models:
  - name: dim_customers
    columns:
      - name: customer_id
        tests:
          - unique
          - not_null
  - name: dim_cars
    columns:
      - name: car_id
        tests:
          - unique
          - not_null
      - name: category_text
        tests:
          - accepted_values:
              values: ['business', 'cargo', 'comfort', 'electro', 'standart']
  - name: dim_calendar
    columns:
      - name: date_id
        tests:
          - unique
          - not_null
```

![](./testirovanie-modeley-4.png "Рисунок 47. Добавление универсальных встроенных тестов (generic tests)"){width=1880px height=1072px}

## Модульные тесты (unit tests)